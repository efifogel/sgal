// Copyright (c) 2004 Israel.
// All rights reserved.
//
// This file is part of SGAL; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; version 2.1 of the
// License. See the file LICENSE.LGPL distributed with SGAL.
//
// Licensees holding a valid commercial license may use this file in
// accordance with the commercial license agreement provided with the
// software.
//
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING
// THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Author(s)     : Efi Fogel         <efifogel@gmail.com>

#include <iterator>
#include <boost/lexical_cast.hpp>

#include "SGAL/basic.hpp"
#include "SGAL/Vrml_formatter.hpp"
#include "SGAL/version.hpp"
#include "SGAL/Container.hpp"
#include "SGAL/Route.hpp"
#include "SGAL/Field.hpp"
#include "SGAL/Field_info.hpp"
#include "SGAL/io_bounding_sphere.hpp"

SGAL_BEGIN_NAMESPACE

//! \brief constructs.
Vrml_formatter::Vrml_formatter(const std::string& filename) :
  Text_formatter(filename)
{ m_export_non_visible = true; }

//! \brief constructs an output formatter.
Vrml_formatter::Vrml_formatter(const std::string& filename, std::ostream& os) :
  Text_formatter(filename, os)
{ m_export_non_visible = true; }

//! \brief constructs an input formatter.
Vrml_formatter::Vrml_formatter(const std::string& filename, std::istream& is) :
  Text_formatter(filename, is)
{ m_export_non_visible = true; }

//! \brief destructor
Vrml_formatter::~Vrml_formatter() { m_names.clear(); }

//! \brief writes the headers of the scene graph.
void Vrml_formatter::begin()
{
  SGAL_assertion(m_out != nullptr);
  // m_old_out_mode = get_mode(*m_out);
  // set_ascii_mode(*m_out);

  out() << "#VRML V2.0 utf8" << std::endl
        << "# Generated by SGAL Version " << SGAL_VERSION << std::endl;
  new_line();
}

//! \brief writes the routing statements.
void Vrml_formatter::end()
{
  // set_mode(*m_out, m_old_out_mode);
}

//! \brief writes a scene-graph node.
inline void Vrml_formatter::write(Shared_container container)
{
  auto route = boost::dynamic_pointer_cast<Route>(container);
  if (route) {
    new_line();
    indent();
    out() << "ROUTE "
          << route->get_source_node()->get_name() << "."
          << route->get_source_field()->get_field_info()->get_name() << " TO "
          << route->get_destination_node()->get_name() << "."
          << route->get_destination_field()->get_field_info()->get_name();
    new_line();
    return;
  }

  /* If the number of shared objects (including this one) is greater than 3,
   * generate a unique name and use it, so that the container can be referred
   * to by the name later on.
   * Check whether 'container' is shared among at least 4 holders.
   * It is held in
   *   (i) Scene_graph::m_containers or Scene_graph::m_instances,
   *  (ii) the parent node, and
   * (iii) the local variable in this function.
   */
  if (container.use_count() > 3) {
    const auto& name = container->get_name();
    if (name.empty()) {
      auto addr = reinterpret_cast<size_t>(&*container);
      std::string name("_");
      name.append(std::to_string(addr));
      container->set_name(name);
    }
  }

  const auto& name = container->get_name();
  if (name.empty()) {
    container->write(this);
    return;
  }
  if (m_names.find(name) != m_names.end()) {
    indent();
    out() << "USE " << name;
    new_line();
    return;
  }

  m_names.insert(name);
  indent();
  out() << "DEF " << name << " ";
  container->write(this);
}

//! \brief writes a declaration statement without default value.
void Vrml_formatter::declaration(const std::string& rule,
                                 const std::string& type,
                                 const std::string& name)
{
  new_line();
  indent();
  out() << rule << " " << type << " " << name;
  new_line();
}

//! \brief writes the container header.
void Vrml_formatter::container_begin(const std::string& tag)
{
  indent();
  out() << tag << " {";
  push_indent();
}

//! \brief writes the container tailer.
void Vrml_formatter::container_end()
{
  pop_indent();
  indent();
  out() << "}";
  new_line();
}

//! \brief writes the header of a container multi-field.
void Vrml_formatter::multi_container_begin(const std::string& name)
{
  new_line();
  indent();
  out() << name << " [";
  new_line();
  push_indent();
}

//! \brief writes the tailer of a container multi-field.
void Vrml_formatter::multi_container_end()
{
  pop_indent();
  indent();
  out() << "]";
  new_line();
}

//! \brief writes the header of a container single-field.
void Vrml_formatter::single_container_begin(const std::string& name)
{
  new_line();
  indent();
  out() << name << " ";
}

//! \brief writes the tailer of a container single-field.
void Vrml_formatter::single_container_end() {}

//! \brief writes a single string field.
inline void Vrml_formatter::single_string(const std::string& name,
                                          const std::string& value,
                                          const std::string& default_value)
{
  if (value == default_value) return;
  new_line();
  indent();
  out() << name << " \"" << value << "\"";
  new_line();
}

//! \brief writes a single Boolean field.
void Vrml_formatter::single_boolean(const std::string& name,
                                    Boolean value, Boolean default_value)
{
  if (value == default_value) return;
  new_line();
  indent();
  out() << name << " " << (value ? "TRUE" : "FALSE");
  new_line();
}

//! \brief writes a multi-Boolean field.
void Vrml_formatter::multi_boolean(const std::string& name,
                                   const std::vector<Boolean>& value,
                                   const std::vector<Boolean>& default_value)
{
  if ((value.size() == 0) || (value.size() != default_value.size())) return;
  if (! std::equal(value.begin(), value.end(), default_value.begin())) return;

  new_line();
  indent();
  out() << name << " [";
  new_line();
  push_indent();
  indent();
  std::copy(value.begin(), value.end(),
            std::ostream_iterator<Boolean>(out(), " "));
  new_line();
  pop_indent();
  indent();
  out() << "]";
  new_line();
}

//! \brief writes a single string field.
inline void
Vrml_formatter::multi_string(const std::string& name,
                             const std::vector<std::string>& value,
                             const std::vector<std::string>& default_value)
{
  if (value.size() == 0) return;
  if ((value.size() == default_value.size()) &&
      std::equal(value.begin(), value.end(), default_value.begin()))
    return;

  new_line();
  indent();
  out() << name << " [";
  new_line();
  push_indent();
  indent();
  std::transform(value.begin(), value.end(),
                 std::ostream_iterator<std::string>(out(), " "),
                 [](const std::string& src)
                 { return std::move(std::string("\"").append(src).append("\"")); });
  new_line();
  pop_indent();
  indent();
  out() << "]";
  new_line();
}

// Single-field declarations of non-simple fields-type fields
//! \brief exports a single Vector2f field.
void Vrml_formatter::single_vector2f(const std::string& rule,
                                     const std::string& type,
                                     const std::string& name,
                                     const Vector2f& value)
{ single_declaration(rule, type, name, value); }

//! \brief exports a single Vector3f field.
void Vrml_formatter::single_vector3f(const std::string& rule,
                                     const std::string& type,
                                     const std::string& name,
                                     const Vector3f& value)
{ single_declaration(rule, type, name, value); }

//! \brief exports a single Vector4f field.
void Vrml_formatter::single_vector4f(const std::string& rule,
                                     const std::string& type,
                                     const std::string& name,
                                     const Vector4f& value)
{ single_declaration(rule, type, name, value); }

//! \brief exports a single Rotation field.
void Vrml_formatter::single_rotation(const std::string& rule,
                                     const std::string& type,
                                     const std::string& name,
                                     const Rotation& value)
{ single_declaration(rule, type, name, value); }

//! \brief exports a single Bounding_sphere field.
void Vrml_formatter::single_bounding_sphere(const std::string& rule,
                                            const std::string& type,
                                            const std::string& name,
                                            const Bounding_sphere& value)
{ single_declaration(rule, type, name, value); }

// Multi-field declarations of non-simple fields-type fields
//! \brief exports a multi-Vector2f field.
void Vrml_formatter::multi_vector2f(const std::string& rule,
                                    const std::string& type,
                                    const std::string& name,
                                    const std::vector<Vector2f>& value)
{ multi_declaration(rule, type, name, value); }

//! \brief exports a multi-Vector3f field.
void Vrml_formatter::multi_vector3f(const std::string& rule,
                                    const std::string& type,
                                    const std::string& name,
                                    const std::vector<Vector3f>& value)
{ multi_declaration(rule, type, name, value); }

//! \brief exports a multi-Vector4f field.
inline void Vrml_formatter::multi_vector4f(const std::string& rule,
                                           const std::string& type,
                                           const std::string& name,
                                           const std::vector<Vector4f>& value)
{ multi_declaration(rule, type, name, value); }

//! \brief exports a multi-Rotation field.
void Vrml_formatter::multi_rotation(const std::string& rule,
                                    const std::string& type,
                                    const std::string& name,
                                    const std::vector<Rotation>& value)
{ multi_declaration(rule, type, name, value); }

//! \brief exports a multi-Bounding_sphere field.
void
Vrml_formatter::multi_bounding_sphere(const std::string& rule,
                                      const std::string& type,
                                      const std::string& name,
                                      const std::vector<Bounding_sphere>& value)
{ multi_declaration(rule, type, name, value); }

// Single-field definitions of non-simple fields-type fields
//! \brief exports a single Vector2f field.
void Vrml_formatter::single_vector2f(const std::string& name,
                                     const Vector2f& value,
                                     const Vector2f& default_value)
{ single_definition(name, value, default_value); }

//! \brief exports a single Vector3f field.
void Vrml_formatter::single_vector3f(const std::string& name,
                                     const Vector3f& value,
                                     const Vector3f& default_value)
{ single_definition(name, value, default_value); }

//! \brief exports a single Vector4f field.
void Vrml_formatter::single_vector4f(const std::string& name,
                                     const Vector4f& value,
                                     const Vector4f& default_value)
{ single_definition(name, value, default_value); }

//! \brief exports a single Rotation field.
void Vrml_formatter::single_rotation(const std::string& name,
                                     const Rotation& value,
                                     const Rotation& default_value)
{ single_definition(name, value, default_value); }

//! \brief exports a single Bounding_sphere field.
void
Vrml_formatter::single_bounding_sphere(const std::string& name,
                                       const Bounding_sphere& value,
                                       const Bounding_sphere& default_value)
{ single_definition(name, value, default_value); }

// Multi-field definitions of non-simple fields-type fields
//! \brief exports a single Vector2f field.
void Vrml_formatter::multi_vector2f(const std::string& name,
                                    const std::vector<Vector2f>& value,
                                    const std::vector<Vector2f>& default_value)
{ multi_definition(name, value, default_value); }

//! \brief exports a single Vector3f field.
void Vrml_formatter::multi_vector3f(const std::string& name,
                                    const std::vector<Vector3f>& value,
                                    const std::vector<Vector3f>& default_value)
{ multi_definition(name, value, default_value); }

//! \brief exports a single Vector4f field.
void Vrml_formatter::multi_vector4f(const std::string& name,
                                    const std::vector<Vector4f>& value,
                                    const std::vector<Vector4f>& default_value)
{ multi_definition(name, value, default_value); }

//! \brief exports a single Rotation field.
void Vrml_formatter::multi_rotation(const std::string& name,
                                    const std::vector<Rotation>& value,
                                    const std::vector<Rotation>& default_value)
{ multi_definition(name, value, default_value); }

//! \brief exports a single Bounding_sphere field.
void Vrml_formatter::
multi_bounding_sphere(const std::string& name,
                      const std::vector<Bounding_sphere>& value,
                      const std::vector<Bounding_sphere>& default_value)
{ multi_definition(name, value, default_value); }

SGAL_END_NAMESPACE
