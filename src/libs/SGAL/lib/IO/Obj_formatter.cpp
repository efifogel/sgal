// Copyright (c) 2014 Israel.
// All rights reserved.
//
// This file is part of SGAL; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; version 2.1 of the
// License. See the file LICENSE.LGPL distributed with SGAL.
//
// Licensees holding a valid commercial license may use this file in
// accordance with the commercial license agreement provided with the
// software.
//
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING
// THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Author(s)     : Efi Fogel         <efifogel@gmail.com>

/*! \file
 */

#include <iterator>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/exception.hpp>
#include <boost/lexical_cast.hpp>

#include "SGAL/Obj_formatter.hpp"
#include "SGAL/version.hpp"
#include "SGAL/Container.hpp"
#include "SGAL/Transform.hpp"
#include "SGAL/Mesh_set.hpp"
#include "SGAL/Appearance.hpp"
#include "SGAL/Material.hpp"
#include "SGAL/Coord_array.hpp"
#include "SGAL/version.hpp"

SGAL_BEGIN_NAMESPACE

//! \brief constructs default.
Obj_formatter::Obj_formatter(const std::string& filename) :
  Text_formatter(filename),
  m_index(1),
  m_num_appearances(0),
  m_is_visible(false)
{
  m_matrices.emplace(Matrix4f());
  m_export_non_visible = false;
}

//! \brief constructs an output formatter from an output stream.
Obj_formatter::Obj_formatter(const std::string& filename, std::ostream& os) :
  Text_formatter(filename, os),
  m_index(1),
  m_num_appearances(0),
  m_is_visible(false)
{
  m_matrices.emplace(Matrix4f());
  m_export_non_visible = false;
}

//! \brief constructs an input formatter.
Obj_formatter::Obj_formatter(const std::string& filename, std::istream& is) :
  Text_formatter(filename, is),
  m_index(1),
  m_num_appearances(0),
  m_is_visible(false)
{  m_export_non_visible = false; }

//! \brief destructor
Obj_formatter::~Obj_formatter()
{ m_matrices.pop(); }

//! \brief exports the headers of the scene graph.
void Obj_formatter::begin()
{
  SGAL_assertion(m_out != nullptr);

  indent();
  out() << "# Generated by SGAL Version " << SGAL_VERSION;
  new_line();

  namespace fi = boost::filesystem;
  fi::path material_path(m_filename);
  material_path.replace_extension("mtl");
  indent();
  out() << "mtllib " << material_path.filename().string();
  new_line();

  // Open the material output stream
  m_material_out.open(material_path.string());
  // m_old_out_mode = get_mode(*m_out);
  // set_ascii_mode(*m_out);
}

//! \brief exports the routing statements.
void Obj_formatter::end()
{ m_material_out.close(); }

//! \brief exports a vertex.
void Obj_formatter::vertex(const Vector3f& p)
{
  indent();
  out() << "v " << p[0] << " " << p[1] << " " << p[2];
  new_line();
}

//! \brief exports a triangular facet.
void Obj_formatter::triangle(Uint i0, Uint i1, Uint i2)
{
  indent();
  out() << "f " << i0+m_index << " " << i1+m_index << " " << i2+m_index;
  new_line();
}

//! \brief exports a quadrilateral facet.
void Obj_formatter::quad(Uint i0, Uint i1, Uint i2, Uint i3)
{
  out() << "f " << i0+m_index << " " << i1+m_index << " " << i2+m_index
        << " " << i3+m_index;
  new_line();
}

//! \brief exports a scene-graph container.
void Obj_formatter::write(Shared_container container)
{
  auto transform = boost::dynamic_pointer_cast<Transform>(container);
  if (transform) {
    // Push the transform matrix
    const Matrix4f& new_matrix = transform->get_matrix();
    const Matrix4f& top_matrix = m_matrices.top();
    m_matrices.emplace(Matrix4f(top_matrix, new_matrix));

    // Process the children.
    transform->write(this);

    // Pop the transform matrix
    m_matrices.pop();
    return;
  }

  auto appearance = boost::dynamic_pointer_cast<Appearance>(container);
  if (appearance) {
    auto name = appearance->get_name();
    if (!name.empty()) {
      if (0 == name.compare(0, 3, "MAT")) name.append("_");
      material_out() << "newmtl " << name << std::endl;
      out() << "usemtl " << name << std::endl;
    }
    else {
      // MSVC 10 complains that the statement below is an ambiguous call to
      // overloaded function
      // name.append("MAT").append(std::to_string(m_num_appearances));
      name.append("MAT").append(boost::lexical_cast<std::string>(m_num_appearances));
      material_out() << "newmtl " << name << std::endl;
      out() << "usemtl " << name << std::endl;
    }
    ++m_num_appearances;
    auto material = appearance->get_material();
    auto ambient = material->get_ambient_intensity();
    const auto& emissive = material->get_emissive_color();
    material_out() << "Ka " << emissive[0] * ambient << " "
                                  << emissive[1] * ambient << " "
                                  << emissive[2] * ambient << std::endl;
    const auto& diffuse = material->get_diffuse_color();
    material_out() << "Kd " << diffuse[0] << " "
                                  << diffuse[1] << " "
                                  << diffuse[2] << std::endl;
    const auto& specular = material->get_specular_color();
    material_out() << "Ks " << specular[0]
                                  << " " << specular[1]
                                  << " " << specular[2]
                                  << std::endl;
    auto shininess = material->get_shininess() * 1000.;
    material_out() << "Ns " << shininess << std::endl;
    auto transparency = material->get_transparency();
    material_out() << "d " << 1.0 - transparency << std::endl;
    return;
  }

  container->write(this);
}

SGAL_END_NAMESPACE
