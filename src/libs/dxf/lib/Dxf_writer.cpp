// Copyright (c) 2018 Israel.
// All rights reserved.
//
// This file is part of SGAL; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; version 2.1 of the
// License. See the file LICENSE.LGPL distributed with SGAL.
//
// Licensees holding a valid commercial license may use this file in
// accordance with the commercial license agreement provided with the
// software.
//
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING
// THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE.
//
// SPDX-License-Identifier: GPL-3.0+
//
// Author(s): Efi Fogel         <efifogel@gmail.com>

#include <iostream>
#include <iomanip>

#include "SGAL/basic.hpp"
#include "SGAL/Scene_graph.hpp"
#include "SGAL/Configuration.hpp"
#include "SGAL/Dxf_configuration.hpp"

#include "dxf/basic.hpp"
#include "dxf/Dxf_writer.hpp"
#include "dxf/Dxf_data.hpp"
#include "dxf/Dxf_header.hpp"
#include "dxf/Dxf_header_wrapper.hpp"
#include "dxf/Dxf_base_table.hpp"
#include "dxf/Dxf_base_entry.hpp"
#include "dxf/Dxf_dictionary_object.hpp"

DXF_BEGIN_NAMESPACE

//! \brief constructs
Dxf_writer::Dxf_writer() :
  m_data(nullptr),
  m_owned(false)
{}

//! \brief destructs.
Dxf_writer::~Dxf_writer()
{
  if (m_owned) {
    delete m_data;
    m_data = nullptr;
    m_owned = false;
  }
}

//! \brief writes a scene to an output stream in the dxf format.
void Dxf_writer::operator()(SGAL::Scene_graph* scene_graph,
                            std::ostream& os, const std::string& filename,
                            bool /* is_binary */)
{
  set_out(os);
  m_scene_graph = scene_graph;

  // Populate the Dxf_data with the minimal requirements
  m_data = new Dxf_data;
  init();

  // Export
  SGAL_assertion(m_scene_graph);
  auto* conf = m_scene_graph->get_configuration();
  SGAL_assertion(conf);
  auto dxf_conf = conf->get_dxf_configuration();
  SGAL_assertion(dxf_conf);
  auto version = dxf_conf->get_version();

  std::string comment("Generated by SGAL Version ");
  comment.append(std::to_string(SGAL_VERSION));
  export_string(999, comment);
  export_section([&]() { export_header(); });
  if (! m_data->m_classes.empty() || ((version > 12)))
    export_section([&]() { export_classes(); });
  if (! m_data->tables_empty()) export_section([&]() { export_tables(); });
  if (! m_data->m_blocks.empty()) export_section([&]() { export_blocks(); });
  export_section([&]() { export_entities(); });
  if (! m_data->m_objects.empty()) export_section([&]() { export_objects(); });

  if (! m_data->m_thumbnailimage.empty())
    export_section([&]() { export_thumbnailimage(); });
  if (! m_data->m_acdsdata.empty())
    export_section([&]() { export_acdsdata(); });
  export_string(0, "EOF");
}

//! \brief exports a given code.
void Dxf_writer::export_code(int code)
{ out() << std::setw(3) << code << std::endl; }

//! \brief export a string item.
void Dxf_writer::export_string(int code, const std::string& str)
{
  if (str.empty()) return;
  export_code(code);
  export_value(str);
}

#if ! ClimbingStats_COMPILER_CXX_GENERIC_LAMDAS
struct Visitor : public boost::static_visitor<void> {
  Visitor(Dxf_writer& writer, const std::list<int>& codes) :
    m_writer(writer),
    m_codes(codes)
  {}

  Dxf_writer& m_writer;
  const std::list<int>& m_codes;

  template <typename T>
  void operator()(const T* value)
  {
    for (auto code : m_codes) {
      m_writer.export_code(code);
      m_writer.export_value(*value++);
    }
  }
};
#endif

//! \brief writes the HEADER section.
void Dxf_writer::export_header()
{
  export_string(2, "HEADER");

  SGAL_assertion(m_data);
  auto& header = m_data->m_header;
  if (header.empty()) return;

  auto& vars = header.m_variables;

  // my_visitor visitor(m_data);
  const auto& members = Dxf_header_wrapper::s_header_members;

  for (const auto& var : vars) {
    export_code(9);
    export_value(var.m_name);
    auto it = members.find(var.m_name);
    SGAL_assertion(it != members.end());
    const auto& codes = it->second;
#if ClimbingStats_COMPILER_CXX_GENERIC_LAMDAS
    boost::apply_visitor([&](auto&& value) {
        for (auto code : codes) {
          export_code(code);
          export_value(*value++);
        }
      }, var.m_value);
#else
    Visitor visitor(*this, codes);
    boost::apply_visitor(visitor, var.m_value);
#endif
  }
}

//! \brief writes the CLASSES section.
void Dxf_writer::export_classes()
{
  export_string(2, "CLASSES");
  SGAL_assertion(m_data);
  auto& classes = m_data->m_classes;
  if (classes.empty()) return;

  //! \todo Export classes
}

//! \brief writes the TABLES section.
void Dxf_writer::export_tables()
{
  export_string(2, "TABLES");

  SGAL_assertion(m_data);
  if (m_data->tables_empty()) return;

  auto& vport_table = m_data->m_vport_table;
  if (! vport_table.empty()) export_table(vport_table, "VPORT");

  auto& ltype_table = m_data->m_ltype_table;
  if (! ltype_table.empty()) export_table(ltype_table, "LTYPE");

  auto& layer_table = m_data->m_layer_table;
  if (! layer_table.empty()) export_table(layer_table, "LAYER");

  auto& style_table = m_data->m_style_table;
  if (! style_table.empty()) export_table(style_table, "STYLE");

  auto& view_table = m_data->m_view_table;
  if (! view_table.empty()) export_table(view_table, "VIEW");

  auto& ucs_table = m_data->m_ucs_table;
  if (! ucs_table.empty()) export_table(ucs_table, "UCS");

  auto& appid_table = m_data->m_appid_table;
  if (! appid_table.empty()) export_table(appid_table, "APPID");

  auto& dimstyle_table = m_data->m_dimstyle_table;
  if (! dimstyle_table.empty()) export_table(dimstyle_table, "DIMSTYLE");

  auto& block_record_table = m_data->m_block_record_table;
  if (! block_record_table.empty())
    export_table(block_record_table, "BLOCK_RECORD");
}

//! \brief writes the BLOCKS section.
void Dxf_writer::export_blocks()
{
  export_string(2, "BLOCKS");
  SGAL_assertion(m_data);
  auto& blocks = m_data->m_blocks;
  if (blocks.empty()) return;

  //! \todo Export BLOCKS
}

//! \brief writes the ENTITIES section.
void Dxf_writer::export_entities()
{
  export_string(2, "ENTITIES");

  SGAL_assertion(m_data);
  auto& entities = m_data->m_entities;
  if (entities.empty()) return;

  //! \todo Export ENTITIES
}

//! \brief writes the OBJECTS section.
void Dxf_writer::export_objects()
{
  export_string(2, "OBJECTS");

  SGAL_assertion(m_data);
  auto& objects = m_data->m_objects;
  if (objects.empty()) return;

  //! \todo Export ENTITIES
}

//! \brief writes the THUMBNAILIMAGE section.
void Dxf_writer::export_thumbnailimage()
{
  export_string(2, "THUMBNAILIMAGE");

  SGAL_assertion(m_data);
  auto& thumbnailimage = m_data->m_thumbnailimage;
  if (thumbnailimage.empty()) return;

  //! \todo Export THUMBNAILIMAGE
}

//! \brief writes the ACDSDATA section.
void Dxf_writer::export_acdsdata()
{
  export_string(2, "ACDSDATA");
  SGAL_assertion(m_data);
  auto& acdsdata = m_data->m_acdsdata;
  if (acdsdata.empty()) return;

  //! \todo Export ACDSDATA
}

//! \brief exports a given base_table.
void Dxf_writer::export_base_table(const Dxf_base_table& base_table)
{
  export_string(5, base_table.m_handle);
  export_string(360, base_table.m_owner_dict);
  export_string(330, base_table.m_owner_obj);
}

//! \brief exports a given entry.
void Dxf_writer::export_base_entry(const Dxf_base_entry& base_entry)
{
  export_string(5, base_entry.m_handle);
  export_string(360, base_entry.m_owner_dict);
  export_string(330, base_entry.m_owner_obj);
}

void Dxf_writer::export_entry(const Dxf_vport_entry& entry)
{
  auto& members = Dxf_record_wrapper<Dxf_vport_entry>::s_record_members;
  export_member(2, entry, members);

  export_string(2, entry.m_name);
  export_item(70, entry.m_flags);
  export_item(10, entry.m_lower_left[0]);
  export_item(20, entry.m_lower_left[1]);
  export_item(11, entry.m_upper_right[0]);
  export_item(21, entry.m_upper_right[1]);
  export_item(12, entry.m_view_center[0]);
  export_item(22, entry.m_view_center[1]);
  export_item(13, entry.m_snap_base[0]);
  export_item(23, entry.m_snap_base[1]);
  export_item(14, entry.m_snap_spacing[0]);
  export_item(24, entry.m_snap_spacing[1]);
  export_item(15, entry.m_grid_spacing[0]);
  export_item(25, entry.m_grid_spacing[1]);
  export_item(16, entry.m_view_direction[0]);
  export_item(26, entry.m_view_direction[1]);
  export_item(36, entry.m_view_direction[2]);
  export_item(17, entry.m_view_target[0]);
  export_item(27, entry.m_view_target[1]);
  export_item(37, entry.m_view_target[2]);
  export_item(40, entry.m_view_height);
  export_item(41, entry.m_aspect_ratio);
  export_item(42, entry.m_lens_length);
  export_item(43, entry.m_front_clipping_plane);
  export_item(44, entry.m_back_clipping_plane);
  export_item(45, entry.m_view_height);
  export_item(50, entry.m_snap_rotation_angle);
  export_item(51, entry.m_view_twist_angle);
  export_string(331, entry.m_soft_frozen_layer);
  export_string(341, entry.m_hard_frozen_layer);
  export_string(1, entry.m_plot_style_sheet);
  export_item(71, entry.m_view_mode);
  export_item(72, entry.m_circle_sides);
  export_item(73, entry.m_fast_zoom);
  export_item(74, entry.m_ucs_icon);
  export_item(75, entry.m_snap_on);
  export_item(76, entry.m_grid_on);
  export_item(77, entry.m_snap_style);
  export_item(78, entry.m_snap_isopair);
  export_item(281, entry.m_render_mode);
  export_item(65, entry.m_ucs_up);
  export_item(110, entry.m_ucs_origin[0]);
  export_item(120, entry.m_ucs_origin[1]);
  export_item(130, entry.m_ucs_origin[2]);
  export_item(111, entry.m_ucs_x_axis[0]);
  export_item(121, entry.m_ucs_x_axis[1]);
  export_item(131, entry.m_ucs_x_axis[2]);
  export_item(112, entry.m_ucs_y_axis[0]);
  export_item(122, entry.m_ucs_y_axis[1]);
  export_item(132, entry.m_ucs_y_axis[2]);
  export_item(345, entry.m_ucs_handle);
  export_item(346, entry.m_base_ucs_handle);
  export_item(79, entry.m_orthographic_type);
  export_item(146, entry.m_elevation);
  export_item(170, entry.m_shade_plot_setting);
  export_item(61, entry.m_major_grid_lines);
  export_item(332, entry.m_background_object_pointer);
  export_item(333, entry.m_shade_plot_object_pointer);
  export_item(348, entry.m_visual_style_object_pointer);
  export_item(292, entry.m_is_default_lighting_on);
  export_item(282, entry.m_default_lighting_type);
  export_item(141, entry.m_brightness);
  export_item(142, entry.m_contrast);
  export_item(63, entry.m_ambient_color);
  export_item(421, entry.m_ambient_color_i32);
  export_item(431, entry.m_ambient_color_name);
}

void Dxf_writer::export_entry(const Dxf_appid_entry& entry)
{
}

void Dxf_writer::export_entry(const Dxf_block_record_entry& entry)
{
}

void Dxf_writer::export_entry(const Dxf_dimstyle_entry& entry)
{
}

void Dxf_writer::export_entry(const Dxf_layer_entry& entry)
{
  export_string(2, entry.m_name);
  export_item(70, entry.m_flags);
  export_item(62, entry.m_color_index);
  export_item(420, entry.m_color, static_cast<int32_t>(-1));
  export_string(6, entry.m_line_type);

  //! \todo export optional
  // (290, entry.m_is_layer_plotted);
  // (370, entry.m_line_weight);
  // (390, entry.m_plot_style_pointer);
  // (347, entry.m_material_handle);
}

void Dxf_writer::export_entry(const Dxf_ltype_entry& entry)
{
  export_string(2, entry.m_name);
  export_item(70, entry.m_flags);
  export_string(3, entry.m_description);
  export_item(72, entry.m_alignment_code);
  export_item(73, entry.m_element_count);
  export_item(40, entry.m_total_pattern_length);

  //! \todo export optional
  // (49, entry.m_dash_dot_space_lengths);
  // (74, entry.m_complex_line_type_element_types);
  // (75, entry.m_shape_numbers);
  // (340, entry.m_style_pointers);
  // (46, entry.m_scale_values);
  // (50, entry.m_rotation_angles);
  // (44, entry.m_offsets);
  // (45, entry.m_offsets);
  // (9, entry.m_text_strings);
}

void Dxf_writer::export_entry(const Dxf_style_entry& entry)
{
}

void Dxf_writer::export_entry(const Dxf_ucs_entry& entry)
{
}

void Dxf_writer::export_entry(const Dxf_view_entry& entry)
{
}

//! \brief initializes with the minimal requirements.
void Dxf_writer::init()
{
  SGAL_assertion(m_scene_graph);
  auto* conf = m_scene_graph->get_configuration();
  SGAL_assertion(conf);
  auto dxf_conf = conf->get_dxf_configuration();
  SGAL_assertion(dxf_conf);
  auto version = dxf_conf->get_version();
  auto it = Dxf_header::s_version_names.find(version);

  if (version <= 12) {
    // Minimal
    auto& vars = m_data->m_header.m_variables;
    SGAL_assertion(it != Dxf_header::s_version_names.end());
    vars.emplace_back("$ACADVER", new std::string(it->second));
    return;
  }

  // HEADER variables
  auto& vars = m_data->m_header.m_variables;
  vars.emplace_back("$ACADVER", new std::string(it->second));
  vars.emplace_back("$HANDSEED", new std::string("20000"));

  // CLASSES

  // TABLES

  // VPORT
  auto& vport_table = m_data->m_vport_table;

  vport_table.m_entries.emplace_back();
  auto& vport_entry = vport_table.m_entries.back();
  vport_entry.m_name = "*ACTIVE";
  vport_entry.m_flags = 0;
  vport_entry.m_lower_left[0] = 0.0;
  vport_entry.m_lower_left[1] = 0.0;
  vport_entry.m_upper_right[0] = 1.0;
  vport_entry.m_upper_right[1] = 1.0;
  vport_entry.m_view_center[0] = 209.475294253;
  vport_entry.m_view_center[1] = 86.0026335861;
  vport_entry.m_snap_base[0] = 0;
  vport_entry.m_snap_base[1] = 0;
  vport_entry.m_snap_spacing[0] = 10;
  vport_entry.m_snap_spacing[1] = 10;
  vport_entry.m_grid_spacing[0] = 10;
  vport_entry.m_grid_spacing[1] = 10;
  vport_entry.m_view_direction[0] = 0;
  vport_entry.m_view_direction[1] = 0;
  vport_entry.m_view_direction[2] = 1;
  vport_entry.m_view_target[0] = 0;
  vport_entry.m_view_target[1] = 0;
  vport_entry.m_view_target[1] = 0;
  vport_entry.m_view_height = 319.744231092;
  vport_entry.m_aspect_ratio = 2.12946428571;
  vport_entry.m_lens_length = 50;
  vport_entry.m_front_clipping_plane = 0;
  vport_entry.m_back_clipping_plane = 0;
  vport_entry.m_snap_rotation_angle = 0;
  vport_entry.m_view_twist_angle = 0;
  vport_entry.m_view_mode = 0;
  vport_entry.m_circle_sides = 100;
  vport_entry.m_fast_zoom = 1;
  vport_entry.m_ucs_icon = 3;
  vport_entry.m_snap_on = 0;
  vport_entry.m_grid_on = 0;
  vport_entry.m_snap_style = 0;
  vport_entry.m_snap_isopair = 0;
  vport_entry.m_render_mode = 0;
  vport_entry.m_ucs_up = 1;
  vport_entry.m_ucs_origin[0] = 0;
  vport_entry.m_ucs_origin[1] = 0;
  vport_entry.m_ucs_origin[2] = 0;
  vport_entry.m_ucs_x_axis[0] = 1;
  vport_entry.m_ucs_x_axis[1] = 0;
  vport_entry.m_ucs_x_axis[2] = 0;
  vport_entry.m_ucs_y_axis[0] = 0;
  vport_entry.m_ucs_y_axis[1] = 1;
  vport_entry.m_ucs_y_axis[2] = 0;
  vport_entry.m_orthographic_type = 0;
  vport_entry.m_elevation = 0;
  vport_entry.m_visual_style_object_pointer = "10020";
  // vport_entry.(60) = 7;
  // vport_entry.(61) = 5;
  vport_entry.m_is_default_lighting_on = 1;
  vport_entry.m_default_lighting_type = 1;
  vport_entry.m_brightness = 0;
  vport_entry.m_contrast = 0;
  vport_entry.m_ambient_color = 250;
  vport_entry.m_ambient_color_i32 = 3358443;

  // LTYPE
  auto& ltype_table = m_data->m_ltype_table;

  ltype_table.m_entries.emplace_back();
  auto& ltype_entry1 = ltype_table.m_entries.back();
  ltype_entry1.m_name.assign("ByBlock");
  ltype_entry1.m_flags = 0;
  ltype_entry1.m_description = "";
  ltype_entry1.m_alignment_code = 65;
  ltype_entry1.m_element_count = 0;
  ltype_entry1.m_total_pattern_length = 0.0;

  ltype_table.m_entries.emplace_back();
  auto& ltype_entry2 = ltype_table.m_entries.back();
  ltype_entry2.m_name.assign("ByLayer");
  ltype_entry2.m_flags = 0;
  ltype_entry2.m_description = "";
  ltype_entry2.m_alignment_code = 65;
  ltype_entry2.m_element_count = 0;
  ltype_entry2.m_total_pattern_length = 0.0;

  ltype_table.m_entries.emplace_back();
  auto& ltype_entry3 = ltype_table.m_entries.back();
  ltype_entry3.m_name.assign("Continuous");
  ltype_entry3.m_flags = 0;
  ltype_entry3.m_description = "Solid line";
  ltype_entry3.m_alignment_code = 65;
  ltype_entry3.m_element_count = 0;
  ltype_entry3.m_total_pattern_length = 0.0;

  // LAYER
  auto& layer_table = m_data->m_layer_table;

  layer_table.m_entries.emplace_back();
  auto& layer_entry = layer_table.m_entries.back();
  layer_entry.m_name = "0";
  layer_entry.m_flags = 64;
  layer_entry.m_color_index = 7;
  layer_entry.m_line_type = "Continuous";

  // STYLE
  auto& style_table = m_data->m_style_table;

  style_table.m_entries.emplace_back();
  auto& style_entry = style_table.m_entries.back();
  style_entry.m_name = "Standard";
  style_entry.m_flags = 0;
  style_entry.m_text_height = 0.0;
  style_entry.m_width_factor = 1.0;
  style_entry.m_oblique_angle = 0.0;
  style_entry.m_text_generation_flags = 0;
  style_entry.m_last_height_used = 1.0;
  style_entry.m_primary_font_file_name = "txt";
  style_entry.m_big_font_file_name = "";

  // VIEW can be empty
  // UCS can be empty
  auto& appid_table = m_data->m_appid_table;

  appid_table.m_entries.emplace_back();
  auto& appid_entry = appid_table.m_entries.back();
  appid_entry.m_name = "ACAD";
  appid_entry.m_flags = 0;

  // DIMSTYLE
  auto& dimstyle_table = m_data->m_dimstyle_table;

  dimstyle_table.m_entries.emplace_back();
  auto& dimstyle_entry = dimstyle_table.m_entries.back();
  dimstyle_entry.m_name = "Standard";
  dimstyle_entry.m_flags = 0;
  dimstyle_entry.m_dimensioning_scale_factor = 1.0;
  dimstyle_entry.m_dimensioning_arrow_size = 0.18;
  dimstyle_entry.m_dimension_extension_line_offset = 0.0625;
  dimstyle_entry.m_dimension_line_increment = 0.38;
  dimstyle_entry.m_dimension_extension_line_extension = 0.18;
  dimstyle_entry.m_dimension_distance_rounding_value = 0.0;
  dimstyle_entry.m_dimension_line_extension = 0.0;
  dimstyle_entry.m_dimension_plus_tolerance = 0.0;
  dimstyle_entry.m_dimension_minus_tolerance = 0.0;
  dimstyle_entry.m_dimensioning_text_height = 0.18;
  dimstyle_entry.m_center_mark_size = 0.09;
  dimstyle_entry.m_dimensioning_tick_size = 0.0;
  dimstyle_entry.m_alternate_dimensioning_scale_factor = 25.4;
  dimstyle_entry.m_dimension_linear_measurement_scale_factor = 1;
  dimstyle_entry.m_dimension_vertical_text_position = 0;
  dimstyle_entry.m_dimension_unit_tolerance_decimal_places = 1;
  dimstyle_entry.m_dimension_line_gap = 0.09;
  dimstyle_entry.m_alternate_dimensioning_decimal_places = 0;
  dimstyle_entry.m_generate_dimension_tolerances = 0;
  dimstyle_entry.m_generate_dimension_limits = 0;
  dimstyle_entry.m_dimension_text_inside_horizontal = 0;
  dimstyle_entry.m_dimension_text_outside_horizontal = 1;
  dimstyle_entry.m_suppress_first_dimension_extension_line = 0;
  dimstyle_entry.m_suppress_second_dimension_extension_line = 0;
  dimstyle_entry.m_text_above_dimension_line = 0;
  dimstyle_entry.m_dimension_unit_zero_suppression = 0;
  dimstyle_entry.m_dimension_angle_zero_suppression = 0;
  dimstyle_entry.m_alternate_dimensioning_unit_rounding = 0;
  dimstyle_entry.m_use_alternate_dimensioning = 2;
  dimstyle_entry.m_dimension_tolerance_displace_scale_factor = 0;
  dimstyle_entry.m_use_separate_arrow_blocks_for_dimensions = 0;
  dimstyle_entry.m_force_dimension_text_inside_extensions = 0;
  dimstyle_entry.m_suppress_outside_extension_dimension_lines = 0;
  dimstyle_entry.m_dimension_line_color = 0;
  dimstyle_entry.m_dimension_extension_line_color = 0;
  dimstyle_entry.m_dimension_text_color = 0;
  dimstyle_entry.m_angular_dimension_precision = 0;
  dimstyle_entry.m_force_dimension_line_extensions_outside_if_text_exists = 4;
  dimstyle_entry.m_dimension_tolerace_decimal_places = 4;
  dimstyle_entry.m_alternate_dimensioning_units = 2;
  dimstyle_entry.m_alternate_dimensioning_tolerance_decimal_places = 2;
  dimstyle_entry.m_dimensioning_angle_format = 0;
  dimstyle_entry.m_dimension_precision = 0;
  dimstyle_entry.m_dimension_non_angular_units = 2;
  dimstyle_entry.m_dimension_decilam_separator_char = 46;
  dimstyle_entry.m_dimension_text_movement_rule = 0;
  dimstyle_entry.m_dimension_text_justification = 0;
  // dimstyle_entry.DIMSD1 = 0;
  // dimstyle_entry.DIMSD2 = 0;
  dimstyle_entry.m_dimension_tolerance_vertical_justification = 1;
  dimstyle_entry.m_dimension_tolerance_zero_suppression = 0;
  dimstyle_entry.m_alternate_dimensioning_zero_suppression = 0;
  dimstyle_entry.m_alternate_dimensioning_tolerance_zero_suppression = 0;
  dimstyle_entry.m_dimension_cursor_controls_text_position = 0;
  dimstyle_entry.m_dimension_text_and_arrow_placement = 3;
  dimstyle_entry.m_dimension_text_style = "Standard";
  dimstyle_entry.m_dimension_leader_block_name = "";
  dimstyle_entry.m_dimension_line_weight = -2;
  dimstyle_entry.m_dimension_extension_line_weight = -2;

  // BLOCK_RECORD
  auto& block_record_table = m_data->m_block_record_table;

  block_record_table.m_entries.emplace_back();
  auto& block_record_entry1 = block_record_table.m_entries.back();
  block_record_entry1.m_name = "*Model_Space";
  block_record_entry1.m_insertion_units = 0;
  block_record_entry1.m_explodability = 1;
  block_record_entry1.m_scalability = 0;

  block_record_table.m_entries.emplace_back();
  auto& block_record_entry2 = block_record_table.m_entries.back();
  block_record_entry2.m_name = "*Paper_Space";
  block_record_entry2.m_insertion_units = 0;
  block_record_entry2.m_explodability = 1;
  block_record_entry2.m_scalability = 0;

  // BLOCKS
  auto& blocks = m_data->m_blocks;

  blocks.emplace_back();
  auto& block1 = blocks.back();
  block1.m_layer_name = "0";
  block1.m_name = "*Model_Space";
  block1.m_flags = 0;
  block1.m_base_point[0] = 0.0;
  block1.m_base_point[1] = 0.0;
  block1.m_base_point[2] = 0.0;
  block1.m_name = "*Model_Space";
  block1.m_xref_path_name = "";

  // *PAPER_SPACE
  blocks.emplace_back();
  auto& block2 = blocks.back();
  block2.m_layer_name = "0";
  block2.m_name = "*Paper_Space";
  block2.m_flags = 0;
  block2.m_base_point[0] = 0.0;
  block2.m_base_point[1] = 0.0;
  block2.m_base_point[2] = 0.0;
  block2.m_name = "*Paper_Space";
  block2.m_xref_path_name = "";

  // ENtitIES can be empty.

  // OBJECTS
  auto& objects = m_data->m_objects;

  // DICTIONARY - the root dict - one entry named ACAD_GROUP
  auto* dictionary_object1 = new Dxf_dictionary_object;
  objects.push_back(dictionary_object1);
  dictionary_object1->m_duplicate_record_handling = 1;
  dictionary_object1->m_entry_name = "ACAD_GROUP";

  // DICTONARY ACAD_GROUP can be empty
  auto* dictionary_object2 = new Dxf_dictionary_object;
  objects.push_back(dictionary_object2);
  dictionary_object2->m_duplicate_record_handling = 1;
}

DXF_END_NAMESPACE
